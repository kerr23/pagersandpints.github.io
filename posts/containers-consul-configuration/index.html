<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Containers, Configuration, and Consul :: Pagers and Pints — DevOps, SRE and Beer</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Through the history of technology, configuration management has driven many design patterns. Empires have been built upon things such as Chef, Ansible, or Puppet all with the intent to remove barriers in managing configuration files for applications deployed in various places. One of the challenges with the traditional approach is the people who understand the configuration(the QA team, developers etc.) are usually different from the people who are managing the configs in Chef."/>
<meta name="keywords" content="DevOps, SRE, Site Reliability, Pager"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="../../posts/containers-consul-configuration/" />


<link rel="stylesheet" href="../../assets/style.css">

  <link rel="stylesheet" href="../../assets/green.css">



<link rel="stylesheet" href="../../style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="../../img/favicon/green.png">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Containers, Configuration, and Consul :: Pagers and Pints — DevOps, SRE and Beer" />
<meta name="twitter:description" content="Through the history of technology, configuration management has driven many design patterns. Empires have been built upon things such as Chef, Ansible, or Puppet all with the intent to remove barriers in managing configuration files for applications deployed in various places. One of the challenges with the traditional approach is the people who understand the configuration(the QA team, developers etc.) are usually different from the people who are managing the configs in Chef." />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="Kendrick Martin&lt;kmartinix@gmail.com&gt;" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Containers, Configuration, and Consul :: Pagers and Pints — DevOps, SRE and Beer">
<meta property="og:description" content="Through the history of technology, configuration management has driven many design patterns. Empires have been built upon things such as Chef, Ansible, or Puppet all with the intent to remove barriers in managing configuration files for applications deployed in various places. One of the challenges with the traditional approach is the people who understand the configuration(the QA team, developers etc.) are usually different from the people who are managing the configs in Chef." />
<meta property="og:url" content="/posts/containers-consul-configuration/" />
<meta property="og:site_name" content="Containers, Configuration, and Consul" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-05-27 16:49:41 -0700 -0700" />











</head>
<body class="">


<div class="container">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="../../">
  <div class="logo">
    Pagers and Pints
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="../../posts/containers-consul-configuration/">Containers, Configuration, and Consul</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-05-27
    </span>
    
    <span class="post-author">::
      Kendrick Martin&lt;kmartinix@gmail.com&gt;
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="../../tags/docker/">docker</a>&nbsp;
    
    #<a href="../../tags/consul/">consul</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<p>Through the history of technology, configuration management has driven many design patterns.
Empires have been built upon things such as Chef, Ansible, or Puppet all with the intent
to remove barriers in managing configuration files for applications deployed in various places.
One of the challenges with the traditional approach is the people who understand the configuration(the QA
team, developers etc.) are usually different from the people who are managing the configs in Chef. This can create
an awkward back and forth with changing application tunables or updating endpoints between different departments, This industry challenge has driven a lot of effort to reduce barriers between the development team, and the teams that manage/monitor production systems, and while this effort and conversation has been good it is by no means a solved problem.</p>

<p>Now add Docker to all this and you&rsquo;re presented with even more teeth to gnaw. Because one of the selling points of Docker is it&rsquo;s binary integrity, there have been several approaches made to try and integrate configuration management inside containers. People have tried to Chef/Puppet inside a container at startup, or bake all configuration into an app at build time, or rebuild the container every time you deploy.</p>

<p>None of these really solve anything. Running chef/puppet inside a container is problematic, and doesn&rsquo;t remove the challenge with who manages the config data. If you put all the config data in the container at build-time you&rsquo;re creating a security vulnerability by comingling production and development config data. Rebuilding the containers removes the binary-integrity advantage that docker gives you.</p>

<p>One approach I&rsquo;ve found to work well is to use <a href="https://consul.io">Hashicorp Consul</a> to provide a key/value store for your configuration. Because the k/v interface is straight forward, you can create a solution that allows the team owning the service to see and manage it&rsquo;s configs from your dev environments to wherever else it gets deployed.</p>

<p>By utilizing <a href="https://github.com/hashicorp/envconsul">envconsul</a> you can preload a process shell environment
with variables named after consul keys. This means if your applications are designed to expect their configuration
to come from the <a href="https://12factor.net/config">environment</a>, you can create a workflow pipeline to store your configurations
in an easy to access, human readible, and highly available consul cluster. I&rsquo;m not going to cover setting up a consul cluster, or any of the steps you take in monitoring or backing up the data, I&rsquo;m going to focus solely on how to pull configuration data for your application.</p>

<h2 id="setup-is-fairly-straight-forward">Setup is fairly straight forward</h2>

<p>In this example we&rsquo;ll use a  config file using erb syntax in a rails application, however this would work with any application that expects values to exist in the shell environment it&rsquo;s run in.</p>

<p><code>test_value: &lt;%= ENV['RAILS_TEST']%&gt;</code></p>

<p>Envconsul allows you to strip a pre-deteremined section off the start of the key name. This allows you to segregate your keys based on environments while keeping the configuration files the same. Decide on a key structure that best fits your needs. The approch I would recommend is creating a top-level key an sub keys for each of the envirnoments you deploy your code to. Ex: <code>/environment/staging</code> and <code>/environment/production</code> and then under that all your key&rsquo;s will exist. Creating the key for the example we have would look something like.</p>

<p><code>curl -X PUT consul:8500/v1/kv/environment/staging/rails_test --data 'foo'</code>
<code>curl -X PUT consul:8500/v1/kv/environment/production/rails_test --data 'bar'</code></p>

<p>Then in your Dockerfile when you start your application you want to start it via envconsul. Envconsul provides a series of flags so I recommend creating a startup.sh file that is your application entry point. For an example rails app, my startup file would look something like
<code>/usr/local/bin/envconsul -consul-addr=consul:8500 -once -sanitize -upcase  -prefix environment/$DEPLOYED_ENVIRONMENT bundle exec puma -e $RAILS_ENV -b tcp://0.0.0.0:9292</code></p>

<ul>
<li>-consul-addr is pretty straight forward</li>
<li>-once keeps envconsul from attempting to continually poll consul. That feature doesn&rsquo;t work doesn&rsquo;t work well with rails, so we&rsquo;re limiting it to poll once. YMMV with this funcationality.</li>
<li>-sanitize This removes any non-standard values from the key and replace them with underscores</li>
<li>-upcase By upcasing all variables you guarentee a case you&rsquo;re expecting.</li>
<li>-prefix The portion of your consul k/v data to focus on and strip off.</li>
<li>and the rest is the command to run, in this case we&rsquo;re launching puma via bundler</li>
</ul>

<p>When I go to run my docker container, I simply pass the RAILS_ENV and DEPLOYED_ENVIRONMENT values in at run time.</p>

<p><code>docker run -e RAILS_ENV=production -e DEPLOYED_ENVIRONMENT=staging my_app</code></p>

<p>I&rsquo;ve created an <a href="https://github.com/kendrickm/envconsul-docker-demo">example repo</a> that creates a rails app and a locally running consul server to demonstrate this very thing.</p>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      
      <span class="button next">
        <a href="../../posts/amazon-maintenance-and-your-rds-instances/">
          <span class="button__text">Amazon Maintenance and your RDS Instances</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 Powered by <a href="http://gohugo.io">Hugo</a></span>
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
    
  </div>
</footer>

<script src="../../assets/main.js"></script>
<script src="../../assets/prism.js"></script>





  
</div>

</body>
</html>

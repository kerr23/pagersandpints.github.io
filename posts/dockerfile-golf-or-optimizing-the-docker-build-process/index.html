<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Dockerfile Golf (or optimizing the Docker build process) :: Pagers and Pints — DevOps, SRE and Beer</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="I was working with a friend of mine on his startup Down For Whatever and he wanted to use Docker.
I created a docker farm for him and we&amp;rsquo;re using Centurion for deployments, we signed up for a docker hub account to store images and started pushing code.
A few days later he emailed me saying that he wanted to switch to capistrano for code deployments instead of building a docker image each time because pushing the image to docker hub took too damn long."/>
<meta name="keywords" content="DevOps, SRE, Site Reliability, Pager"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="../../posts/dockerfile-golf-or-optimizing-the-docker-build-process/" />


<link rel="stylesheet" href="../../assets/style.css">

  <link rel="stylesheet" href="../../assets/green.css">



<link rel="stylesheet" href="../../style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="../../img/favicon/green.png">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Dockerfile Golf (or optimizing the Docker build process) :: Pagers and Pints — DevOps, SRE and Beer" />
<meta name="twitter:description" content="I was working with a friend of mine on his startup Down For Whatever and he wanted to use Docker.
I created a docker farm for him and we&amp;rsquo;re using Centurion for deployments, we signed up for a docker hub account to store images and started pushing code.
A few days later he emailed me saying that he wanted to switch to capistrano for code deployments instead of building a docker image each time because pushing the image to docker hub took too damn long." />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="Dave Kerr" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Dockerfile Golf (or optimizing the Docker build process) :: Pagers and Pints — DevOps, SRE and Beer">
<meta property="og:description" content="I was working with a friend of mine on his startup Down For Whatever and he wanted to use Docker.
I created a docker farm for him and we&amp;rsquo;re using Centurion for deployments, we signed up for a docker hub account to store images and started pushing code.
A few days later he emailed me saying that he wanted to switch to capistrano for code deployments instead of building a docker image each time because pushing the image to docker hub took too damn long." />
<meta property="og:url" content="/posts/dockerfile-golf-or-optimizing-the-docker-build-process/" />
<meta property="og:site_name" content="Dockerfile Golf (or optimizing the Docker build process)" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2014-08-29 21:19:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="../../">
  <div class="logo">
    Pagers and Pints
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="../../posts/dockerfile-golf-or-optimizing-the-docker-build-process/">Dockerfile Golf (or optimizing the Docker build process)</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2014-08-29
    </span>
    
    <span class="post-author">::
      Dave Kerr
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="../../tags/docker/">docker</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<p>I was working with a friend of mine on his startup <a href="http://signup.dfw.io/">Down For Whatever</a> and he wanted to use Docker.</p>

<p>I created a docker farm for him and we&rsquo;re using <a href="https://github.com/newrelic/centurion">Centurion</a> for deployments, we signed up for a <a href="https://hub.docker.com/">docker hub</a> account to store images and started pushing code.</p>

<p>A few days later he emailed me saying that he wanted to switch to capistrano for code deployments instead of building a docker image each time because pushing the image to docker hub took too damn long. (upwards of 10 minutes for him at it&rsquo;s worst)</p>

<p>That felt wrong, and kind of dirty. To me, docker is about creating a bundle of code that you can deploy anywhere. Not about creating a bundle of infrastructure that then you can then deploy into.</p>

<p>It was also surprising because I had started off with a Dockerfile based on <a href="http://ilikestuffblog.com/2014/01/06/how-to-skip-bundle-install-when-deploying-a-rails-app-to-docker/">Brian Morearty&rsquo;s blog post</a> about skipping the bundle install each time you build a docker image. So I didn&rsquo;t think I had a lot of optimization left available to me.</p>

<p>But once we got into Golfing around with the Dockerfile and the .dockerignore file we found massive improvements to be had.</p>

<h2 id="the-dockerignore-file">The .dockerignore file</h2>

<p>One of the issues that we found out right away was that he had 500M of log files in his app&rsquo;s log directory. So we added log/* to the .dockerignore. We were also picking up the .git directory, the db/*.sqlite3 databases, etc.</p>

<p>Once we removed those we dropped around 600M off of the size of our docker image, and that helped quite a bit.</p>

<p>Here&rsquo;s what we ended up with in the .dockerignore</p>

<pre><code class="language-docker">.git  
config/centurion  
log/*  
db/*.sqlite3  
db/*.sqlite3-journal  
.bundle  
tags  
vendor/cache/*  
tmp/*  
*.sh  
Procfile*  
test  
spec  
</code></pre>

<h2 id="the-dockerfile">The Dockerfile</h2>

<p>Next we looked into the Dockerfile itself. Here&rsquo;s what we started with.</p>

<pre><code class="language-docker">FROM dfw1/base:latest  
  
USER root  
RUN mkdir -p /opt/app/dfw  
WORKDIR /opt/app/dfw  
ADD Gemfile /opt/app/dfw/Gemfile  
ADD Gemfile.lock /opt/app/dfw/Gemfile.lock  
RUN chown -R app:app /opt/app/dfw  
USER app  
RUN jruby -S bundle install --without development test --no-color --path /opt/app/dfw  
ADD . /opt/app/dfw  
USER root  
RUN chown -R app:app /opt/app/dfw  
ADD ./container/dfw-supervisor.conf /etc/supervisor.d/dfw.conf  
ADD ./container/dfw-nginx.conf /etc/nginx/sites-enabled/dfw.conf  
USER app  
RUN EXECJS\_RUNTIME='Node' JRUBY\_OPTS=&quot;-X-C&quot; RAILS_ENV=production jruby -S bundle exec rake assets:precompile  
USER root   
</code></pre>

<p>Yeah, that kind of sucks. So we started some Dockerfile golf.</p>

<p>( The base image that I call is basically &ldquo;Install a bunch of stuff and then run supervisord as my CMD&rdquo; )</p>

<h2 id="optimization-goals">Optimization Goals</h2>

<p>I kept a couple of goals in mind while going through the dockerfile.
* Create as few layers as possible
* I actually had this drilled in me from the early days of Docker back when <a href="https://github.com/docker/docker/issues/1171">AUFS had a 42 layer limit</a> so I was already grouping my &lsquo;RUN&rsquo; commands and trying to be as sparse as possible elsewhere.
* There should only be one big layer that isn&rsquo;t cached and that&rsquo;s the layer with the code in it. 
* We found that with the above dockefile we were pushing a 70 MB layer and then a 100 MB layer and 15 MB layer. That was too many layers and too large. </p>

<h2 id="what-we-learned">What We Learned</h2>

<p><strong>Avoid USER switching (if you can)</strong><br />
The first thing that I didn&rsquo;t like was all of the USER switching. Each switch is a layer that needs to be pushed, and though it&rsquo;s small pushing still takes a few seconds each for the transfer and for the layer verification.</p>

<p>In my new dockerfile all of the RUN commands run as root. The application itself runs as the app user thanks to supervisord.</p>

<p>You just need to know where to fix the permissions after the fact.</p>

<p><strong>Sequence Matters!</strong></p>

<p>Look at all the work i&rsquo;m doing AFTER the line: ADD . /opt/app/dfw
Nothing after that line will ever be cached (because we&rsquo;re building a docker image because we&rsquo;ve changed code) even though a lot of it will rarely change.</p>

<p>Move the static ADDs like supervisord config&rsquo;s to the top of the Dockerfile before the un-cacheable add.</p>

<p><strong>After those two changes we&rsquo;re looking better</strong></p>

<pre><code class="language-docker">FROM dfw1/base:latest  
  
RUN mkdir -p /opt/app/dfw  
WORKDIR /opt/app/dfw  
ADD ./container/dfw-supervisor.conf /etc/supervisor.d/dfw.conf  
ADD ./container/dfw-nginx.conf /etc/nginx/sites-enabled/dfw.conf  
ADD Gemfile /opt/app/dfw/Gemfile  
ADD Gemfile.lock /opt/app/dfw/Gemfile.lock  
RUN chown -R app:app /opt/app/dfw  
RUN jruby -S bundle install --without development test --no-color --path /opt/app/dfw  
ADD . /opt/app/dfw  
RUN chown -R app:app /opt/app/dfw  
RUN EXECJS\_RUNTIME='Node' JRUBY\_OPTS=&quot;-X-C&quot; RAILS_ENV=production jruby -S bundle exec rake assets:precompile  
</code></pre>

<p>But there are a few things we can still do.</p>

<h2 id="try-to-dry-up-the-dockerfile">Try to DRY up the Dockerfile</h2>

<p>My &ldquo;dfw1/base&rdquo; image has a massive &lsquo;RUN&rsquo; in it that&rsquo;s joined by a bunch of &amp;&amp;&lsquo;s 
I have some things in this file that could be moved up into that RUN so that it&rsquo;s just 1 layer.</p>

<p>Specifically my <code>mkdir -p /opt/app/dfw.</code></p>

<p>Sure, not all of the apps that use that base image will use /opt/app/dfw but it doesn&rsquo;t hurt those apps for it to be there as an empty directory.</p>

<p>Also, since all of my apps will live in /opt/app/ and be run as &lsquo;app&rsquo; I can
take out the first <code>chown -R app:app /opt/app/dfw</code> and have it in the &lsquo;base&rsquo; image as just
<code>chown -R app:app /opt/app</code> (that also helps squash the dockerfile for other apps i build off that image)</p>

<p><strong>Beware the chown!</strong></p>

<p>This one was a huge /facepalm for me.</p>

<p>Look at what i do:</p>

<pre><code class="language-docker">ADD . /opt/app/dfw  
RUN chown -R app:app /opt/app/dfw  
</code></pre>

<p>I HAVE to chown the dfw directory to app:app because Docker ADDs create files with UID 0. 
So app can&rsquo;t write to it&rsquo;s logs or create any cache files, etc.</p>

<p>But think about what we&rsquo;ve done.
Layer 1: ADD ~72M of source
Layer 2: touch every file in that 72M of source to update it&rsquo;s user info.</p>

<p>Basically I now have two 72M layers that need to be pushed!</p>

<p>This one is a puzzler to fix. </p>

<p>I solved it by changing my CMD strategy. 
The only CMD in my images was <code>CMD \[&quot;supervisord&quot;,&quot;-c&quot;,&quot;/etc/supervisord.conf&quot;\]</code></p>

<p>I switched that to call a shell script:</p>

<pre><code>chown -R app:app /opt/app  
supervisord -c /etc/supervisord.conf  
</code></pre>

<p>Now I could take all the chown&rsquo;s out of my images and we&rsquo;re not duplicating layers unnecessarily.<br />
It also opened up quite a few optimization paths for my general workflow to add other things to that shell script instead of doing it in the layers.</p>

<p><strong>Not everything needs to be done in the Dockerfile</strong></p>

<p>At this point we&rsquo;re really well optimized. However there&rsquo;s one thing that still took quite a long time (as it usually does) and that&rsquo;s precompiling the assets for Rails.</p>

<p>My friend said, &ldquo;Can&rsquo;t we just do that outside of docker?&rdquo; I&rsquo;m not a rails expert by any means, but he is and if he thought we could do it I&rsquo;d give it a try.</p>

<p>We were already using a build script to create / push our docker images. It&rsquo;s effectively.:<br />
<code>docker build -t dfw1/dfw:latest . &amp;&amp; docker push dfw1/dfw:latest</code></p>

<p>We&rsquo;re developing on macs using boot2docker, which means that really all of the &lsquo;docker build&rsquo; work is being done inside a virtualbox vm, which isn&rsquo;t the fastest way.</p>

<p>Also, in the container we only have jruby, which takes a bit of time to bootstrap itself.</p>

<p>Running the rake ahead of time cuts down the build time pretty significantly.</p>

<h2 id="summary">Summary</h2>

<p>In the end we knocked about 9 minutes or more off the build/push of our dockerfiles and my friend was no longer calling for moving to capistrano. Our Dockerfile ended up being really nice and concise</p>

<pre><code class="language-docker">FROM dfw1/base:latest  
ADD Gemfile /opt/app/dfw/Gemfile  
ADD Gemfile.lock /opt/app/dfw/Gemfile.lock  
RUN RAILS_ENV=production /opt/jruby/bin/jruby -S bundle install --without development test --no-color --path /opt/app/dfw  
ADD . /opt/app/dfw  
</code></pre>

<p>It&rsquo;s still not perfect. The push phase still takes way to long, and the &lsquo;already pushed&rsquo; images take a couple seconds each to determine that they&rsquo;ve already been pushed.</p>

<p>We&rsquo;ve speculated that if the push phase could run in parallel, or just faster we could shave 20 seconds or more off the build.  But as it is, we&rsquo;re content with what we have.</p>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="../../posts/introducing-mrtuner-and-rdstune/">
          <span class="button__icon">←</span>
          <span class="button__text">Introducing MrTuner and RDSTune</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="../../posts/tune-your-postgres-rds-instance-via-parameter-groups/">
          <span class="button__text">Tune your Postgres RDS instance via parameter groups</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 Powered by <a href="http://gohugo.io">Hugo</a></span>
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
    
  </div>
</footer>

<script src="../../assets/main.js"></script>
<script src="../../assets/prism.js"></script>





  
</div>

</body>
</html>
